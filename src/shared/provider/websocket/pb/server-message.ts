/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: api/server-message.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";

export class ServerMessage extends pb_1.Message {
	#one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9]];
	constructor(
		data?:
			| any[]
			| ({} & (
					| {
							playerTurnStart?: PlayerTurnStart;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: never;
							quizStart?: never;
							quizResult?: never;
							otoshidamaEvent?: never;
							rankingUpdate?: never;
							gameStart?: never;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: SugorokuMoveUpdate;
							playerMovementDisplay?: never;
							quizStart?: never;
							quizResult?: never;
							otoshidamaEvent?: never;
							rankingUpdate?: never;
							gameStart?: never;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: PlayerMovementDisplay;
							quizStart?: never;
							quizResult?: never;
							otoshidamaEvent?: never;
							rankingUpdate?: never;
							gameStart?: never;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: never;
							quizStart?: QuizStart;
							quizResult?: never;
							otoshidamaEvent?: never;
							rankingUpdate?: never;
							gameStart?: never;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: never;
							quizStart?: never;
							quizResult?: QuizResult;
							otoshidamaEvent?: never;
							rankingUpdate?: never;
							gameStart?: never;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: never;
							quizStart?: never;
							quizResult?: never;
							otoshidamaEvent?: OtoshidamaEvent;
							rankingUpdate?: never;
							gameStart?: never;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: never;
							quizStart?: never;
							quizResult?: never;
							otoshidamaEvent?: never;
							rankingUpdate?: RankingUpdate;
							gameStart?: never;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: never;
							quizStart?: never;
							quizResult?: never;
							otoshidamaEvent?: never;
							rankingUpdate?: never;
							gameStart?: GameStart;
							gameEnd?: never;
					  }
					| {
							playerTurnStart?: never;
							sugorokuMoveUpdate?: never;
							playerMovementDisplay?: never;
							quizStart?: never;
							quizResult?: never;
							otoshidamaEvent?: never;
							rankingUpdate?: never;
							gameStart?: never;
							gameEnd?: GameEnd;
					  }
			  )),
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("playerTurnStart" in data && data.playerTurnStart != undefined) {
				this.playerTurnStart = data.playerTurnStart;
			}
			if ("sugorokuMoveUpdate" in data && data.sugorokuMoveUpdate != undefined) {
				this.sugorokuMoveUpdate = data.sugorokuMoveUpdate;
			}
			if ("playerMovementDisplay" in data && data.playerMovementDisplay != undefined) {
				this.playerMovementDisplay = data.playerMovementDisplay;
			}
			if ("quizStart" in data && data.quizStart != undefined) {
				this.quizStart = data.quizStart;
			}
			if ("quizResult" in data && data.quizResult != undefined) {
				this.quizResult = data.quizResult;
			}
			if ("otoshidamaEvent" in data && data.otoshidamaEvent != undefined) {
				this.otoshidamaEvent = data.otoshidamaEvent;
			}
			if ("rankingUpdate" in data && data.rankingUpdate != undefined) {
				this.rankingUpdate = data.rankingUpdate;
			}
			if ("gameStart" in data && data.gameStart != undefined) {
				this.gameStart = data.gameStart;
			}
			if ("gameEnd" in data && data.gameEnd != undefined) {
				this.gameEnd = data.gameEnd;
			}
		}
	}
	get playerTurnStart() {
		return pb_1.Message.getWrapperField(this, PlayerTurnStart, 1) as PlayerTurnStart;
	}
	set playerTurnStart(value: PlayerTurnStart) {
		pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
	}
	get has_playerTurnStart() {
		return pb_1.Message.getField(this, 1) != null;
	}
	get sugorokuMoveUpdate() {
		return pb_1.Message.getWrapperField(this, SugorokuMoveUpdate, 2) as SugorokuMoveUpdate;
	}
	set sugorokuMoveUpdate(value: SugorokuMoveUpdate) {
		pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
	}
	get has_sugorokuMoveUpdate() {
		return pb_1.Message.getField(this, 2) != null;
	}
	get playerMovementDisplay() {
		return pb_1.Message.getWrapperField(this, PlayerMovementDisplay, 3) as PlayerMovementDisplay;
	}
	set playerMovementDisplay(value: PlayerMovementDisplay) {
		pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
	}
	get has_playerMovementDisplay() {
		return pb_1.Message.getField(this, 3) != null;
	}
	get quizStart() {
		return pb_1.Message.getWrapperField(this, QuizStart, 4) as QuizStart;
	}
	set quizStart(value: QuizStart) {
		pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
	}
	get has_quizStart() {
		return pb_1.Message.getField(this, 4) != null;
	}
	get quizResult() {
		return pb_1.Message.getWrapperField(this, QuizResult, 5) as QuizResult;
	}
	set quizResult(value: QuizResult) {
		pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
	}
	get has_quizResult() {
		return pb_1.Message.getField(this, 5) != null;
	}
	get otoshidamaEvent() {
		return pb_1.Message.getWrapperField(this, OtoshidamaEvent, 6) as OtoshidamaEvent;
	}
	set otoshidamaEvent(value: OtoshidamaEvent) {
		pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
	}
	get has_otoshidamaEvent() {
		return pb_1.Message.getField(this, 6) != null;
	}
	get rankingUpdate() {
		return pb_1.Message.getWrapperField(this, RankingUpdate, 7) as RankingUpdate;
	}
	set rankingUpdate(value: RankingUpdate) {
		pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
	}
	get has_rankingUpdate() {
		return pb_1.Message.getField(this, 7) != null;
	}
	get gameStart() {
		return pb_1.Message.getWrapperField(this, GameStart, 8) as GameStart;
	}
	set gameStart(value: GameStart) {
		pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
	}
	get has_gameStart() {
		return pb_1.Message.getField(this, 8) != null;
	}
	get gameEnd() {
		return pb_1.Message.getWrapperField(this, GameEnd, 9) as GameEnd;
	}
	set gameEnd(value: GameEnd) {
		pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
	}
	get has_gameEnd() {
		return pb_1.Message.getField(this, 9) != null;
	}
	get type() {
		const cases: {
			[index: number]:
				| "none"
				| "playerTurnStart"
				| "sugorokuMoveUpdate"
				| "playerMovementDisplay"
				| "quizStart"
				| "quizResult"
				| "otoshidamaEvent"
				| "rankingUpdate"
				| "gameStart"
				| "gameEnd";
		} = {
			0: "none",
			1: "playerTurnStart",
			2: "sugorokuMoveUpdate",
			3: "playerMovementDisplay",
			4: "quizStart",
			5: "quizResult",
			6: "otoshidamaEvent",
			7: "rankingUpdate",
			8: "gameStart",
			9: "gameEnd",
		};
		return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9])];
	}
	static fromObject(data: {
		playerTurnStart?: ReturnType<typeof PlayerTurnStart.prototype.toObject>;
		sugorokuMoveUpdate?: ReturnType<typeof SugorokuMoveUpdate.prototype.toObject>;
		playerMovementDisplay?: ReturnType<typeof PlayerMovementDisplay.prototype.toObject>;
		quizStart?: ReturnType<typeof QuizStart.prototype.toObject>;
		quizResult?: ReturnType<typeof QuizResult.prototype.toObject>;
		otoshidamaEvent?: ReturnType<typeof OtoshidamaEvent.prototype.toObject>;
		rankingUpdate?: ReturnType<typeof RankingUpdate.prototype.toObject>;
		gameStart?: ReturnType<typeof GameStart.prototype.toObject>;
		gameEnd?: ReturnType<typeof GameEnd.prototype.toObject>;
	}): ServerMessage {
		const message = new ServerMessage({});
		if (data.playerTurnStart != null) {
			message.playerTurnStart = PlayerTurnStart.fromObject(data.playerTurnStart);
		}
		if (data.sugorokuMoveUpdate != null) {
			message.sugorokuMoveUpdate = SugorokuMoveUpdate.fromObject(data.sugorokuMoveUpdate);
		}
		if (data.playerMovementDisplay != null) {
			message.playerMovementDisplay = PlayerMovementDisplay.fromObject(data.playerMovementDisplay);
		}
		if (data.quizStart != null) {
			message.quizStart = QuizStart.fromObject(data.quizStart);
		}
		if (data.quizResult != null) {
			message.quizResult = QuizResult.fromObject(data.quizResult);
		}
		if (data.otoshidamaEvent != null) {
			message.otoshidamaEvent = OtoshidamaEvent.fromObject(data.otoshidamaEvent);
		}
		if (data.rankingUpdate != null) {
			message.rankingUpdate = RankingUpdate.fromObject(data.rankingUpdate);
		}
		if (data.gameStart != null) {
			message.gameStart = GameStart.fromObject(data.gameStart);
		}
		if (data.gameEnd != null) {
			message.gameEnd = GameEnd.fromObject(data.gameEnd);
		}
		return message;
	}
	toObject() {
		const data: {
			playerTurnStart?: ReturnType<typeof PlayerTurnStart.prototype.toObject>;
			sugorokuMoveUpdate?: ReturnType<typeof SugorokuMoveUpdate.prototype.toObject>;
			playerMovementDisplay?: ReturnType<typeof PlayerMovementDisplay.prototype.toObject>;
			quizStart?: ReturnType<typeof QuizStart.prototype.toObject>;
			quizResult?: ReturnType<typeof QuizResult.prototype.toObject>;
			otoshidamaEvent?: ReturnType<typeof OtoshidamaEvent.prototype.toObject>;
			rankingUpdate?: ReturnType<typeof RankingUpdate.prototype.toObject>;
			gameStart?: ReturnType<typeof GameStart.prototype.toObject>;
			gameEnd?: ReturnType<typeof GameEnd.prototype.toObject>;
		} = {};
		if (this.playerTurnStart != null) {
			data.playerTurnStart = this.playerTurnStart.toObject();
		}
		if (this.sugorokuMoveUpdate != null) {
			data.sugorokuMoveUpdate = this.sugorokuMoveUpdate.toObject();
		}
		if (this.playerMovementDisplay != null) {
			data.playerMovementDisplay = this.playerMovementDisplay.toObject();
		}
		if (this.quizStart != null) {
			data.quizStart = this.quizStart.toObject();
		}
		if (this.quizResult != null) {
			data.quizResult = this.quizResult.toObject();
		}
		if (this.otoshidamaEvent != null) {
			data.otoshidamaEvent = this.otoshidamaEvent.toObject();
		}
		if (this.rankingUpdate != null) {
			data.rankingUpdate = this.rankingUpdate.toObject();
		}
		if (this.gameStart != null) {
			data.gameStart = this.gameStart.toObject();
		}
		if (this.gameEnd != null) {
			data.gameEnd = this.gameEnd.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.has_playerTurnStart)
			writer.writeMessage(1, this.playerTurnStart, () => this.playerTurnStart.serialize(writer));
		if (this.has_sugorokuMoveUpdate)
			writer.writeMessage(2, this.sugorokuMoveUpdate, () => this.sugorokuMoveUpdate.serialize(writer));
		if (this.has_playerMovementDisplay)
			writer.writeMessage(3, this.playerMovementDisplay, () => this.playerMovementDisplay.serialize(writer));
		if (this.has_quizStart) writer.writeMessage(4, this.quizStart, () => this.quizStart.serialize(writer));
		if (this.has_quizResult) writer.writeMessage(5, this.quizResult, () => this.quizResult.serialize(writer));
		if (this.has_otoshidamaEvent)
			writer.writeMessage(6, this.otoshidamaEvent, () => this.otoshidamaEvent.serialize(writer));
		if (this.has_rankingUpdate) writer.writeMessage(7, this.rankingUpdate, () => this.rankingUpdate.serialize(writer));
		if (this.has_gameStart) writer.writeMessage(8, this.gameStart, () => this.gameStart.serialize(writer));
		if (this.has_gameEnd) writer.writeMessage(9, this.gameEnd, () => this.gameEnd.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ServerMessage {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new ServerMessage();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					reader.readMessage(
						message.playerTurnStart,
						() => (message.playerTurnStart = PlayerTurnStart.deserialize(reader)),
					);
					break;
				case 2:
					reader.readMessage(
						message.sugorokuMoveUpdate,
						() => (message.sugorokuMoveUpdate = SugorokuMoveUpdate.deserialize(reader)),
					);
					break;
				case 3:
					reader.readMessage(
						message.playerMovementDisplay,
						() => (message.playerMovementDisplay = PlayerMovementDisplay.deserialize(reader)),
					);
					break;
				case 4:
					reader.readMessage(message.quizStart, () => (message.quizStart = QuizStart.deserialize(reader)));
					break;
				case 5:
					reader.readMessage(message.quizResult, () => (message.quizResult = QuizResult.deserialize(reader)));
					break;
				case 6:
					reader.readMessage(
						message.otoshidamaEvent,
						() => (message.otoshidamaEvent = OtoshidamaEvent.deserialize(reader)),
					);
					break;
				case 7:
					reader.readMessage(message.rankingUpdate, () => (message.rankingUpdate = RankingUpdate.deserialize(reader)));
					break;
				case 8:
					reader.readMessage(message.gameStart, () => (message.gameStart = GameStart.deserialize(reader)));
					break;
				case 9:
					reader.readMessage(message.gameEnd, () => (message.gameEnd = GameEnd.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): ServerMessage {
		return ServerMessage.deserialize(bytes);
	}
}
export class PlayerTurnStart extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: PlayerTurnStart.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, PlayerTurnStart.Data, 2) as PlayerTurnStart.Data;
	}
	set data(value: PlayerTurnStart.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof PlayerTurnStart.Data.prototype.toObject>;
	}): PlayerTurnStart {
		const message = new PlayerTurnStart({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = PlayerTurnStart.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof PlayerTurnStart.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PlayerTurnStart {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new PlayerTurnStart();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = PlayerTurnStart.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): PlayerTurnStart {
		return PlayerTurnStart.deserialize(bytes);
	}
}
export namespace PlayerTurnStart {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						playerId?: number;
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("playerId" in data && data.playerId != undefined) {
					this.playerId = data.playerId;
				}
			}
		}
		get playerId() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set playerId(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		static fromObject(data: {
			playerId?: number;
		}): Data {
			const message = new Data({});
			if (data.playerId != null) {
				message.playerId = data.playerId;
			}
			return message;
		}
		toObject() {
			const data: {
				playerId?: number;
			} = {};
			if (this.playerId != null) {
				data.playerId = this.playerId;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.playerId != 0) writer.writeInt32(1, this.playerId);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.playerId = reader.readInt32();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
}
export class SugorokuMoveUpdate extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: SugorokuMoveUpdate.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, SugorokuMoveUpdate.Data, 2) as SugorokuMoveUpdate.Data;
	}
	set data(value: SugorokuMoveUpdate.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof SugorokuMoveUpdate.Data.prototype.toObject>;
	}): SugorokuMoveUpdate {
		const message = new SugorokuMoveUpdate({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = SugorokuMoveUpdate.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof SugorokuMoveUpdate.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SugorokuMoveUpdate {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new SugorokuMoveUpdate();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = SugorokuMoveUpdate.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): SugorokuMoveUpdate {
		return SugorokuMoveUpdate.deserialize(bytes);
	}
}
export namespace SugorokuMoveUpdate {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						playerId?: number;
						stepsMoved?: number;
						newPosition?: number;
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("playerId" in data && data.playerId != undefined) {
					this.playerId = data.playerId;
				}
				if ("stepsMoved" in data && data.stepsMoved != undefined) {
					this.stepsMoved = data.stepsMoved;
				}
				if ("newPosition" in data && data.newPosition != undefined) {
					this.newPosition = data.newPosition;
				}
			}
		}
		get playerId() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set playerId(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		get stepsMoved() {
			return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
		}
		set stepsMoved(value: number) {
			pb_1.Message.setField(this, 2, value);
		}
		get newPosition() {
			return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
		}
		set newPosition(value: number) {
			pb_1.Message.setField(this, 3, value);
		}
		static fromObject(data: {
			playerId?: number;
			stepsMoved?: number;
			newPosition?: number;
		}): Data {
			const message = new Data({});
			if (data.playerId != null) {
				message.playerId = data.playerId;
			}
			if (data.stepsMoved != null) {
				message.stepsMoved = data.stepsMoved;
			}
			if (data.newPosition != null) {
				message.newPosition = data.newPosition;
			}
			return message;
		}
		toObject() {
			const data: {
				playerId?: number;
				stepsMoved?: number;
				newPosition?: number;
			} = {};
			if (this.playerId != null) {
				data.playerId = this.playerId;
			}
			if (this.stepsMoved != null) {
				data.stepsMoved = this.stepsMoved;
			}
			if (this.newPosition != null) {
				data.newPosition = this.newPosition;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.playerId != 0) writer.writeInt32(1, this.playerId);
			if (this.stepsMoved != 0) writer.writeInt32(2, this.stepsMoved);
			if (this.newPosition != 0) writer.writeInt32(3, this.newPosition);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.playerId = reader.readInt32();
						break;
					case 2:
						message.stepsMoved = reader.readInt32();
						break;
					case 3:
						message.newPosition = reader.readInt32();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
}
export class PlayerMovementDisplay extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: PlayerMovementDisplay.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, PlayerMovementDisplay.Data, 2) as PlayerMovementDisplay.Data;
	}
	set data(value: PlayerMovementDisplay.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof PlayerMovementDisplay.Data.prototype.toObject>;
	}): PlayerMovementDisplay {
		const message = new PlayerMovementDisplay({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = PlayerMovementDisplay.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof PlayerMovementDisplay.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PlayerMovementDisplay {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new PlayerMovementDisplay();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = PlayerMovementDisplay.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): PlayerMovementDisplay {
		return PlayerMovementDisplay.deserialize(bytes);
	}
}
export namespace PlayerMovementDisplay {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						playerId?: number;
						newPosition?: number;
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("playerId" in data && data.playerId != undefined) {
					this.playerId = data.playerId;
				}
				if ("newPosition" in data && data.newPosition != undefined) {
					this.newPosition = data.newPosition;
				}
			}
		}
		get playerId() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set playerId(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		get newPosition() {
			return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
		}
		set newPosition(value: number) {
			pb_1.Message.setField(this, 2, value);
		}
		static fromObject(data: {
			playerId?: number;
			newPosition?: number;
		}): Data {
			const message = new Data({});
			if (data.playerId != null) {
				message.playerId = data.playerId;
			}
			if (data.newPosition != null) {
				message.newPosition = data.newPosition;
			}
			return message;
		}
		toObject() {
			const data: {
				playerId?: number;
				newPosition?: number;
			} = {};
			if (this.playerId != null) {
				data.playerId = this.playerId;
			}
			if (this.newPosition != null) {
				data.newPosition = this.newPosition;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.playerId != 0) writer.writeInt32(1, this.playerId);
			if (this.newPosition != 0) writer.writeInt32(2, this.newPosition);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.playerId = reader.readInt32();
						break;
					case 2:
						message.newPosition = reader.readInt32();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
}
export class QuizStart extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: QuizStart.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, QuizStart.Data, 2) as QuizStart.Data;
	}
	set data(value: QuizStart.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof QuizStart.Data.prototype.toObject>;
	}): QuizStart {
		const message = new QuizStart({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = QuizStart.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof QuizStart.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QuizStart {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new QuizStart();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = QuizStart.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): QuizStart {
		return QuizStart.deserialize(bytes);
	}
}
export namespace QuizStart {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						playerId?: number;
						quizQuestion?: string;
						options?: string[];
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("playerId" in data && data.playerId != undefined) {
					this.playerId = data.playerId;
				}
				if ("quizQuestion" in data && data.quizQuestion != undefined) {
					this.quizQuestion = data.quizQuestion;
				}
				if ("options" in data && data.options != undefined) {
					this.options = data.options;
				}
			}
		}
		get playerId() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set playerId(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		get quizQuestion() {
			return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
		}
		set quizQuestion(value: string) {
			pb_1.Message.setField(this, 2, value);
		}
		get options() {
			return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
		}
		set options(value: string[]) {
			pb_1.Message.setField(this, 3, value);
		}
		static fromObject(data: {
			playerId?: number;
			quizQuestion?: string;
			options?: string[];
		}): Data {
			const message = new Data({});
			if (data.playerId != null) {
				message.playerId = data.playerId;
			}
			if (data.quizQuestion != null) {
				message.quizQuestion = data.quizQuestion;
			}
			if (data.options != null) {
				message.options = data.options;
			}
			return message;
		}
		toObject() {
			const data: {
				playerId?: number;
				quizQuestion?: string;
				options?: string[];
			} = {};
			if (this.playerId != null) {
				data.playerId = this.playerId;
			}
			if (this.quizQuestion != null) {
				data.quizQuestion = this.quizQuestion;
			}
			if (this.options != null) {
				data.options = this.options;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.playerId != 0) writer.writeInt32(1, this.playerId);
			if (this.quizQuestion.length) writer.writeString(2, this.quizQuestion);
			if (this.options.length) writer.writeRepeatedString(3, this.options);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.playerId = reader.readInt32();
						break;
					case 2:
						message.quizQuestion = reader.readString();
						break;
					case 3:
						pb_1.Message.addToRepeatedField(message, 3, reader.readString());
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
}
export class QuizResult extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: QuizResult.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, QuizResult.Data, 2) as QuizResult.Data;
	}
	set data(value: QuizResult.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof QuizResult.Data.prototype.toObject>;
	}): QuizResult {
		const message = new QuizResult({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = QuizResult.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof QuizResult.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QuizResult {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new QuizResult();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = QuizResult.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): QuizResult {
		return QuizResult.deserialize(bytes);
	}
}
export namespace QuizResult {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						correctPlayerId?: number;
						otoshidamaAmount?: number;
						message?: string;
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("correctPlayerId" in data && data.correctPlayerId != undefined) {
					this.correctPlayerId = data.correctPlayerId;
				}
				if ("otoshidamaAmount" in data && data.otoshidamaAmount != undefined) {
					this.otoshidamaAmount = data.otoshidamaAmount;
				}
				if ("message" in data && data.message != undefined) {
					this.message = data.message;
				}
			}
		}
		get correctPlayerId() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set correctPlayerId(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		get otoshidamaAmount() {
			return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
		}
		set otoshidamaAmount(value: number) {
			pb_1.Message.setField(this, 2, value);
		}
		get message() {
			return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
		}
		set message(value: string) {
			pb_1.Message.setField(this, 3, value);
		}
		static fromObject(data: {
			correctPlayerId?: number;
			otoshidamaAmount?: number;
			message?: string;
		}): Data {
			const message = new Data({});
			if (data.correctPlayerId != null) {
				message.correctPlayerId = data.correctPlayerId;
			}
			if (data.otoshidamaAmount != null) {
				message.otoshidamaAmount = data.otoshidamaAmount;
			}
			if (data.message != null) {
				message.message = data.message;
			}
			return message;
		}
		toObject() {
			const data: {
				correctPlayerId?: number;
				otoshidamaAmount?: number;
				message?: string;
			} = {};
			if (this.correctPlayerId != null) {
				data.correctPlayerId = this.correctPlayerId;
			}
			if (this.otoshidamaAmount != null) {
				data.otoshidamaAmount = this.otoshidamaAmount;
			}
			if (this.message != null) {
				data.message = this.message;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.correctPlayerId != 0) writer.writeInt32(1, this.correctPlayerId);
			if (this.otoshidamaAmount != 0) writer.writeInt32(2, this.otoshidamaAmount);
			if (this.message.length) writer.writeString(3, this.message);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.correctPlayerId = reader.readInt32();
						break;
					case 2:
						message.otoshidamaAmount = reader.readInt32();
						break;
					case 3:
						message.message = reader.readString();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
}
export class OtoshidamaEvent extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: OtoshidamaEvent.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, OtoshidamaEvent.Data, 2) as OtoshidamaEvent.Data;
	}
	set data(value: OtoshidamaEvent.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof OtoshidamaEvent.Data.prototype.toObject>;
	}): OtoshidamaEvent {
		const message = new OtoshidamaEvent({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = OtoshidamaEvent.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof OtoshidamaEvent.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OtoshidamaEvent {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new OtoshidamaEvent();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = OtoshidamaEvent.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): OtoshidamaEvent {
		return OtoshidamaEvent.deserialize(bytes);
	}
}
export namespace OtoshidamaEvent {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						playerId?: number;
						message?: string;
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("playerId" in data && data.playerId != undefined) {
					this.playerId = data.playerId;
				}
				if ("message" in data && data.message != undefined) {
					this.message = data.message;
				}
			}
		}
		get playerId() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set playerId(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		get message() {
			return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
		}
		set message(value: string) {
			pb_1.Message.setField(this, 2, value);
		}
		static fromObject(data: {
			playerId?: number;
			message?: string;
		}): Data {
			const message = new Data({});
			if (data.playerId != null) {
				message.playerId = data.playerId;
			}
			if (data.message != null) {
				message.message = data.message;
			}
			return message;
		}
		toObject() {
			const data: {
				playerId?: number;
				message?: string;
			} = {};
			if (this.playerId != null) {
				data.playerId = this.playerId;
			}
			if (this.message != null) {
				data.message = this.message;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.playerId != 0) writer.writeInt32(1, this.playerId);
			if (this.message.length) writer.writeString(2, this.message);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.playerId = reader.readInt32();
						break;
					case 2:
						message.message = reader.readString();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
}
export class GameStart extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: GameStart.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, GameStart.Data, 2) as GameStart.Data;
	}
	set data(value: GameStart.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof GameStart.Data.prototype.toObject>;
	}): GameStart {
		const message = new GameStart({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = GameStart.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof GameStart.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GameStart {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new GameStart();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = GameStart.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): GameStart {
		return GameStart.deserialize(bytes);
	}
}
export namespace GameStart {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						playerIds?: number[];
						map?: GameStart.Data.Map;
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("playerIds" in data && data.playerIds != undefined) {
					this.playerIds = data.playerIds;
				}
				if ("map" in data && data.map != undefined) {
					this.map = data.map;
				}
			}
		}
		get playerIds() {
			return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
		}
		set playerIds(value: number[]) {
			pb_1.Message.setField(this, 1, value);
		}
		get map() {
			return pb_1.Message.getWrapperField(this, GameStart.Data.Map, 2) as GameStart.Data.Map;
		}
		set map(value: GameStart.Data.Map) {
			pb_1.Message.setWrapperField(this, 2, value);
		}
		get has_map() {
			return pb_1.Message.getField(this, 2) != null;
		}
		static fromObject(data: {
			playerIds?: number[];
			map?: ReturnType<typeof GameStart.Data.Map.prototype.toObject>;
		}): Data {
			const message = new Data({});
			if (data.playerIds != null) {
				message.playerIds = data.playerIds;
			}
			if (data.map != null) {
				message.map = GameStart.Data.Map.fromObject(data.map);
			}
			return message;
		}
		toObject() {
			const data: {
				playerIds?: number[];
				map?: ReturnType<typeof GameStart.Data.Map.prototype.toObject>;
			} = {};
			if (this.playerIds != null) {
				data.playerIds = this.playerIds;
			}
			if (this.map != null) {
				data.map = this.map.toObject();
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.playerIds.length) writer.writePackedInt32(1, this.playerIds);
			if (this.has_map) writer.writeMessage(2, this.map, () => this.map.serialize(writer));
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.playerIds = reader.readPackedInt32();
						break;
					case 2:
						reader.readMessage(message.map, () => (message.map = GameStart.Data.Map.deserialize(reader)));
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
	export namespace Data {
		export class Map extends pb_1.Message {
			#one_of_decls: number[][] = [];
			constructor(
				data?:
					| any[]
					| {
							squares?: GameStart.Data.Map.squareType[];
					  },
			) {
				super();
				pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
				if (!Array.isArray(data) && typeof data == "object") {
					if ("squares" in data && data.squares != undefined) {
						this.squares = data.squares;
					}
				}
			}
			get squares() {
				return pb_1.Message.getFieldWithDefault(this, 1, []) as GameStart.Data.Map.squareType[];
			}
			set squares(value: GameStart.Data.Map.squareType[]) {
				pb_1.Message.setField(this, 1, value);
			}
			static fromObject(data: {
				squares?: GameStart.Data.Map.squareType[];
			}): Map {
				const message = new Map({});
				if (data.squares != null) {
					message.squares = data.squares;
				}
				return message;
			}
			toObject() {
				const data: {
					squares?: GameStart.Data.Map.squareType[];
				} = {};
				if (this.squares != null) {
					data.squares = this.squares;
				}
				return data;
			}
			serialize(): Uint8Array;
			serialize(w: pb_1.BinaryWriter): void;
			serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
				const writer = w || new pb_1.BinaryWriter();
				if (this.squares.length) writer.writePackedEnum(1, this.squares);
				if (!w) return writer.getResultBuffer();
			}
			static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Map {
				const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
					message = new Map();
				while (reader.nextField()) {
					if (reader.isEndGroup()) break;
					switch (reader.getFieldNumber()) {
						case 1:
							message.squares = reader.readPackedEnum();
							break;
						default:
							reader.skipField();
					}
				}
				return message;
			}
			serializeBinary(): Uint8Array {
				return this.serialize();
			}
			static deserializeBinary(bytes: Uint8Array): Map {
				return Map.deserialize(bytes);
			}
		}
		export namespace Map {
			export enum squareType {
				NORMAL = 0,
				QUIZ = 1,
				OTOSHIDAMA = 2,
				FURIDASHI = 3,
			}
		}
	}
}
export class GameEnd extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: GameEnd.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, GameEnd.Data, 2) as GameEnd.Data;
	}
	set data(value: GameEnd.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof GameEnd.Data.prototype.toObject>;
	}): GameEnd {
		const message = new GameEnd({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = GameEnd.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof GameEnd.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GameEnd {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new GameEnd();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = GameEnd.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): GameEnd {
		return GameEnd.deserialize(bytes);
	}
}
export namespace GameEnd {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						playerId?: number;
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("playerId" in data && data.playerId != undefined) {
					this.playerId = data.playerId;
				}
			}
		}
		get playerId() {
			return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
		}
		set playerId(value: number) {
			pb_1.Message.setField(this, 1, value);
		}
		static fromObject(data: {
			playerId?: number;
		}): Data {
			const message = new Data({});
			if (data.playerId != null) {
				message.playerId = data.playerId;
			}
			return message;
		}
		toObject() {
			const data: {
				playerId?: number;
			} = {};
			if (this.playerId != null) {
				data.playerId = this.playerId;
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.playerId != 0) writer.writeInt32(1, this.playerId);
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						message.playerId = reader.readInt32();
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
}
export class RankingUpdate extends pb_1.Message {
	#one_of_decls: number[][] = [];
	constructor(
		data?:
			| any[]
			| {
					type?: string;
					data?: RankingUpdate.Data;
			  },
	) {
		super();
		pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
		if (!Array.isArray(data) && typeof data == "object") {
			if ("type" in data && data.type != undefined) {
				this.type = data.type;
			}
			if ("data" in data && data.data != undefined) {
				this.data = data.data;
			}
		}
	}
	get type() {
		return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
	}
	set type(value: string) {
		pb_1.Message.setField(this, 1, value);
	}
	get data() {
		return pb_1.Message.getWrapperField(this, RankingUpdate.Data, 2) as RankingUpdate.Data;
	}
	set data(value: RankingUpdate.Data) {
		pb_1.Message.setWrapperField(this, 2, value);
	}
	get has_data() {
		return pb_1.Message.getField(this, 2) != null;
	}
	static fromObject(data: {
		type?: string;
		data?: ReturnType<typeof RankingUpdate.Data.prototype.toObject>;
	}): RankingUpdate {
		const message = new RankingUpdate({});
		if (data.type != null) {
			message.type = data.type;
		}
		if (data.data != null) {
			message.data = RankingUpdate.Data.fromObject(data.data);
		}
		return message;
	}
	toObject() {
		const data: {
			type?: string;
			data?: ReturnType<typeof RankingUpdate.Data.prototype.toObject>;
		} = {};
		if (this.type != null) {
			data.type = this.type;
		}
		if (this.data != null) {
			data.data = this.data.toObject();
		}
		return data;
	}
	serialize(): Uint8Array;
	serialize(w: pb_1.BinaryWriter): void;
	serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
		const writer = w || new pb_1.BinaryWriter();
		if (this.type.length) writer.writeString(1, this.type);
		if (this.has_data) writer.writeMessage(2, this.data, () => this.data.serialize(writer));
		if (!w) return writer.getResultBuffer();
	}
	static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RankingUpdate {
		const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
			message = new RankingUpdate();
		while (reader.nextField()) {
			if (reader.isEndGroup()) break;
			switch (reader.getFieldNumber()) {
				case 1:
					message.type = reader.readString();
					break;
				case 2:
					reader.readMessage(message.data, () => (message.data = RankingUpdate.Data.deserialize(reader)));
					break;
				default:
					reader.skipField();
			}
		}
		return message;
	}
	serializeBinary(): Uint8Array {
		return this.serialize();
	}
	static deserializeBinary(bytes: Uint8Array): RankingUpdate {
		return RankingUpdate.deserialize(bytes);
	}
}
export namespace RankingUpdate {
	export class Data extends pb_1.Message {
		#one_of_decls: number[][] = [];
		constructor(
			data?:
				| any[]
				| {
						rankings?: RankingUpdate.Data.Ranking[];
				  },
		) {
			super();
			pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
			if (!Array.isArray(data) && typeof data == "object") {
				if ("rankings" in data && data.rankings != undefined) {
					this.rankings = data.rankings;
				}
			}
		}
		get rankings() {
			return pb_1.Message.getRepeatedWrapperField(this, RankingUpdate.Data.Ranking, 1) as RankingUpdate.Data.Ranking[];
		}
		set rankings(value: RankingUpdate.Data.Ranking[]) {
			pb_1.Message.setRepeatedWrapperField(this, 1, value);
		}
		static fromObject(data: {
			rankings?: ReturnType<typeof RankingUpdate.Data.Ranking.prototype.toObject>[];
		}): Data {
			const message = new Data({});
			if (data.rankings != null) {
				message.rankings = data.rankings.map((item) => RankingUpdate.Data.Ranking.fromObject(item));
			}
			return message;
		}
		toObject() {
			const data: {
				rankings?: ReturnType<typeof RankingUpdate.Data.Ranking.prototype.toObject>[];
			} = {};
			if (this.rankings != null) {
				data.rankings = this.rankings.map((item: RankingUpdate.Data.Ranking) => item.toObject());
			}
			return data;
		}
		serialize(): Uint8Array;
		serialize(w: pb_1.BinaryWriter): void;
		serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
			const writer = w || new pb_1.BinaryWriter();
			if (this.rankings.length)
				writer.writeRepeatedMessage(1, this.rankings, (item: RankingUpdate.Data.Ranking) => item.serialize(writer));
			if (!w) return writer.getResultBuffer();
		}
		static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
			const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
				message = new Data();
			while (reader.nextField()) {
				if (reader.isEndGroup()) break;
				switch (reader.getFieldNumber()) {
					case 1:
						reader.readMessage(message.rankings, () =>
							pb_1.Message.addToRepeatedWrapperField(
								message,
								1,
								RankingUpdate.Data.Ranking.deserialize(reader),
								RankingUpdate.Data.Ranking,
							),
						);
						break;
					default:
						reader.skipField();
				}
			}
			return message;
		}
		serializeBinary(): Uint8Array {
			return this.serialize();
		}
		static deserializeBinary(bytes: Uint8Array): Data {
			return Data.deserialize(bytes);
		}
	}
	export namespace Data {
		export class Ranking extends pb_1.Message {
			#one_of_decls: number[][] = [];
			constructor(
				data?:
					| any[]
					| {
							playerId?: number;
							position?: number;
					  },
			) {
				super();
				pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
				if (!Array.isArray(data) && typeof data == "object") {
					if ("playerId" in data && data.playerId != undefined) {
						this.playerId = data.playerId;
					}
					if ("position" in data && data.position != undefined) {
						this.position = data.position;
					}
				}
			}
			get playerId() {
				return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
			}
			set playerId(value: number) {
				pb_1.Message.setField(this, 1, value);
			}
			get position() {
				return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
			}
			set position(value: number) {
				pb_1.Message.setField(this, 2, value);
			}
			static fromObject(data: {
				playerId?: number;
				position?: number;
			}): Ranking {
				const message = new Ranking({});
				if (data.playerId != null) {
					message.playerId = data.playerId;
				}
				if (data.position != null) {
					message.position = data.position;
				}
				return message;
			}
			toObject() {
				const data: {
					playerId?: number;
					position?: number;
				} = {};
				if (this.playerId != null) {
					data.playerId = this.playerId;
				}
				if (this.position != null) {
					data.position = this.position;
				}
				return data;
			}
			serialize(): Uint8Array;
			serialize(w: pb_1.BinaryWriter): void;
			serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
				const writer = w || new pb_1.BinaryWriter();
				if (this.playerId != 0) writer.writeInt32(1, this.playerId);
				if (this.position != 0) writer.writeInt32(2, this.position);
				if (!w) return writer.getResultBuffer();
			}
			static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Ranking {
				const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
					message = new Ranking();
				while (reader.nextField()) {
					if (reader.isEndGroup()) break;
					switch (reader.getFieldNumber()) {
						case 1:
							message.playerId = reader.readInt32();
							break;
						case 2:
							message.position = reader.readInt32();
							break;
						default:
							reader.skipField();
					}
				}
				return message;
			}
			serializeBinary(): Uint8Array {
				return this.serialize();
			}
			static deserializeBinary(bytes: Uint8Array): Ranking {
				return Ranking.deserialize(bytes);
			}
		}
	}
}
